<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with jLaTeX2HTML 2002 (1.62) JA patch-1.4
patched version by:  Kenshi Muto, Debian Project.
LaTeX2HTML 2002 (1.62),
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>A Common Database Interface (DBI)</TITLE>
<META NAME="description" CONTENT="A Common Database Interface (DBI)">
<META NAME="keywords" CONTENT="DBI">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="jLaTeX2HTML v2002 JA patch-1.4">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="DBI.css">

</HEAD>

<BODY >
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="file:/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev_g.png">   
<BR>
<BR><BR>
<!--End of Navigation Panel-->

<P>

<P>

<P>
<H1 ALIGN="CENTER">A Common Database Interface (DBI)</H1>
<P ALIGN="CENTER"><STRONG>R-Databases Special Interest Group
<BR>mailto:r-sig-db@stat.math.ethz.chr-sig-db@stat.math.ethz.ch
</STRONG></P>
<P ALIGN="CENTER"><STRONG>26 August 2002 (Updated 16 June 2003)</STRONG></P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html29"
  HREF="DBI.html">Version</A>
<LI><A NAME="tex2html30"
  HREF="DBI.html#SECTION00030000000000000000">Introduction</A>
<LI><A NAME="tex2html31"
  HREF="DBI.html#SECTION00040000000000000000">DBI Classes and Methods</A>
<UL>
<LI><A NAME="tex2html32"
  HREF="DBI.html#SECTION00041000000000000000">Class DBIObject</A>
<LI><A NAME="tex2html33"
  HREF="DBI.html#SECTION00042000000000000000">Class DBIDriver</A>
<LI><A NAME="tex2html34"
  HREF="DBI.html#SECTION00043000000000000000">Class DBIConnection</A>
<LI><A NAME="tex2html35"
  HREF="DBI.html#SECTION00044000000000000000">Class DBIResult</A>
</UL><BR>
<LI><A NAME="tex2html36"
  HREF="DBI.html#SECTION00050000000000000000">Data Type Mappings</A>
<LI><A NAME="tex2html37"
  HREF="DBI.html#SECTION00060000000000000000">Utilities</A>
<LI><A NAME="tex2html38"
  HREF="DBI.html#SECTION00070000000000000000">Open Issues and Limitations</A>
<LI><A NAME="tex2html39"
  HREF="DBI.html#SECTION00080000000000000000">Resources</A>
<LI><A NAME="tex2html40"
  HREF="DBI.html#SECTION00090000000000000000">Bibliography</A>
<LI><A NAME="tex2html41"
  HREF="DBI.html#SECTION000100000000000000000">About this document ...</A>
</UL>
<!--End of Table of Contents-->
<P>

<H3>Abstract:</H3>
<DIV>
This document describes a common interface between the S language 
(in its R and S-Plus implementations) and database management systems
(DBMS).  The interface defines a small set of classes and methods
similar in spirit to Perl's DBI, Java's JDBC, Python's DB-API,
and Microsoft's ODBC.
</DIV>
<P>

<P>

<H1><A NAME="SECTION00020000000000000000"></A><A NAME="sec:version"></A><BR>
Version
</H1>
This document describes version 0.1-6 of the database interface
API (application programming interface).

<P>

<H1><A NAME="SECTION00030000000000000000"></A><A NAME="sec:intro"></A><BR>
Introduction
</H1>

<P>
The database interface (DBI) separates the connectivity to the DBMS
into a ``front-end'' and a ``back-end''.  Applications use only the
exposed ``front-end'' API.  The facilities that communicate with
specific DBMS (Oracle, PostgreSQL, etc.) are provided by ``device
drivers'' that get invoked automatically by the S language evaluator.
The following example illustrates some of the DBI capabilities:
<PRE>
## Choose the proper DBMS driver and connect to the server

drv &lt;- dbDriver("ODBC")
con &lt;- dbConnect(drv, "dsn", "usr", "pwd")

## The interface can work at a higher level importing tables 
## as data.frames and exporting data.frames as DBMS tables.

dbListTables(con)
dbListFields(con, "quakes")
if(dbExistsTable(con, "new_results"))
   dbRemoveTable(con, "new_results")
dbWriteTable(con, "new_results", new.output)

## The interface allows lower-level interface to the DBMS
res &lt;- dbSendQuery(con, paste(
            "SELECT g.id, g.mirror, g.diam, e.voltage",
            "FROM geom_table as g, elec_measures as e",
            "WHERE g.id = e.id and g.mirrortype = 'inside'",
            "ORDER BY g.diam"))
out &lt;- NULL
while(!dbHasCompleted(res)){
   chunk &lt;- fetch(res, n = 10000)
   out &lt;- c(out, doit(chunk))
}

## Free up resources
dbClearResult(res)
dbDisconnect(con)
dbUnloadDriver(drv)
</PRE>
(only the first 2 expressions are DBMS-specific - all others are
independent of the database engine itself).

<P>
Individual DBI drivers need not implement all the features we
list below (we indicate those that are optional).  Furthermore,
drivers may extend the core DBI facilities, but we suggest to have
these extensions clearly indicated and documented.

<P>
The following are the elements of the DBI:

<OL>
<LI>A set of classes and methods (Section&nbsp;<A HREF="DBI.html#sec:DBIClasses"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/share/latex2html/icons/crossref.png"></A>)
  that defines what operations are possible and how they are defined, 
  e.g.:
  
<UL>
<LI>connect/disconnect to the DBMS
</LI>
<LI>create and execute statements in the DBMS
</LI>
<LI>extract results/output from statements
</LI>
<LI>error/exception handling
</LI>
<LI>information (meta-data) from database objects
</LI>
<LI>transaction management (optional)
  
</LI>
</UL>

<P>
Some things are left explicitly unspecified, e.g., authentication
  and even the query language, although it is hard to avoid references 
  to SQL and relational database management systems (RDBMS).

<P>
</LI>
<LI>Drivers

<P>
Drivers are collection of functions that implement the functionality
  defined above in the context of specific DBMS, e.g., mSQL, Informix.

<P>
</LI>
<LI>Data type mappings (Section&nbsp;<A HREF="DBI.html#sec:data-mappings"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/share/latex2html/icons/crossref.png"></A>.)

<P>
Mappings and conversions between DBMS data types and R/S objects.
  All drivers should implement the ``basic'' primitives (see below), 
  but may chose to add user-defined conversion function to handle
  more generic objects (e.g., factors, ordered factors, time series,
  arrays, images).

<P>
</LI>
<LI>Utilities (Section&nbsp;<A HREF="DBI.html#sec:utilities"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/share/latex2html/icons/crossref.png"></A>.)

<P>
These facilities help with details such as mapping of identifiers
  between S and DBMS (e.g., <TT>"_"</TT> is illegal in R/S
  names, and <TT>"."</TT> is used for constructing compound SQL
  identifiers), etc.

<P>
</LI>
</OL>

<P>

<H1><A NAME="SECTION00040000000000000000"></A><A NAME="sec:DBIClasses"></A><BR>
DBI Classes and Methods
</H1>
The following are the main DBI classes. They need to be extended
by individual database back-ends (Sybase, Oracle, etc.)  Individual
drivers need to provide methods for the generic functions listed here
(those methods that are optional are so indicated).

<P>
<I>Note: Although R releases prior to 1.4 do not have a formal
concept of classes, we will use the syntax of the S Version
4 classes and methods (available in R releases 1.4 and later as
library <TT>methods</TT>) to convey precisely the DBI class hierarchy,
its methods, and intended behavior.  
</I>

<P>
The DBI classes are <TT>DBIObject</TT>, <TT>DBIDriver</TT>,
<TT>DBIConnection</TT> and <TT>DBIResult</TT>. All these are
<I>virtual</I> classes.  Drivers define new classes that extend
these, e.g., <TT>PgSQLDriver</TT>, <TT>PgSQLConnection</TT>, and
so on.

<DIV ALIGN="CENTER"><A NAME="51"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Class hierarchy for the DBI. The top two layers
are comprised of virtual classes and each lower layer represents
a set of driver-specific implementation classes that provide
the functionality defined by the virtual classes above.</CAPTION>
<TR><TD></TD></TR>
</TABLE>
</DIV>

<DL>
<DT><STRONG><TT>DBIObject</TT>:</STRONG></DT>
<DD>Virtual class<A NAME="tex2html2"
  HREF="#foot55"><SUP>1</SUP></A> that groups all other
  DBI classes.

<P>
</DD>
<DT><STRONG><TT>DBIDriver</TT>:</STRONG></DT>
<DD>Virtual class that groups all DBMS drivers. Each DBMS driver
  extends this class.  Typically generator functions instantiate
  the actual driver objects, e.g., <TT>PgSQL()</TT>, <TT>HDF5()</TT>, 
  <TT>BerkeleyDB()</TT>.

<P>
</DD>
<DT><STRONG><TT>DBIConnection</TT>:</STRONG></DT>
<DD>Virtual class that encapsulates connections to DBMS.

<P>
</DD>
<DT><STRONG><TT>DBIResult</TT>:</STRONG></DT>
<DD>Virtual class that describes the result of a DBMS query or statement.  

<P>
[Q: Should we distinguish between a simple result of DBMS statements 
  e.g., as <TT>delete</TT> from DBMS queries (i.e., those that generate 
  data).]

<P>
</DD>
</DL> 

<P>
The methods <TT>format</TT>, <TT>print</TT>, <TT>show</TT>, 
<TT>dbGetInfo</TT>, and <TT>summary</TT>
are defined (and <I>implemented</I> in the <TT>DBI</TT> package) 
for the <TT>DBIObject</TT> base class, thus available to all 
implementations; individual drivers, however, are free to override 
them as they see fit.
<DL>
<DT><STRONG><TT>format(x, ...)</TT>:</STRONG></DT>
<DD>produces a concise character representation (label) for the
   <TT>DBIObject</TT> <TT>x</TT>.

<P>
</DD>
<DT><STRONG><TT>print(x, ...)</TT>/<TT>show(x)</TT>:</STRONG></DT>
<DD>prints a one-line identification of the object <TT>x</TT>.

<P>
</DD>
<DT><STRONG><TT>summary(object, ...)</TT>:</STRONG></DT>
<DD>produces a concise description of the object.
  The default method for <TT>DBIObject</TT> simply 
  invokes <TT>dbGetInfo(dbObj)</TT> and prints the name-value
  pairs one per line.  Individual implementations may tailor
  this appropriately.

<P>
</DD>
<DT><STRONG><TT>dbGetInfo(dbObj, ...)</TT>:</STRONG></DT>
<DD>extracts information (meta-data) relevant for the
  <TT>DBIObject</TT> <TT>dbObj</TT>.  It may return a list
  of key/value pairs, individual meta-data if supplied
  in the call, or <TT>NULL</TT> if the requested meta-data
  is not available.

<P>
<I>Hint:</I> Driver implementations may choose to allow an 
  argument <TT>what</TT> to specify individual meta-data,  e.g., 
  <TT>dbGetInfo(drv, what = "max.connections")</TT>.

<P>
</DD>
</DL>

<P>
In the next few sub-sections we describe in detail each of these
classes and their methods.

<P>

<H2><A NAME="SECTION00041000000000000000"></A><A NAME="sec:DBIObject"></A><BR>
Class <TT>DBIObject</TT>
</H2>
This class simply groups all DBI classes, and thus all extend it.

<P>

<H2><A NAME="SECTION00042000000000000000"></A><A NAME="sec:DBIDriver"></A><BR>
Class <TT>DBIDriver</TT>
</H2>
This class identifies the database management system. It needs to 
be extended by individual back-ends (Oracle, PostgreSQL, etc.)

<P>
The DBI provides the generator <TT>dbDriver("driverName")</TT> 
which simply invokes the function <TT>driverName()</TT>, which
in turn instantiates the corresponding driver object.

<P>
The <TT>DBIDriver</TT> class defines the following methods:
<DL>
<DT><STRONG><TT>driverName()</TT>:</STRONG></DT>
<DD><A NAME="meth:driverName"></A>  initializes the driver code. The name <TT>driverName</TT> refers to
  the actual generator function for the DBMS, e.g., <TT>RPgSQL()</TT>,
  <TT>RODBC()</TT>, <TT>HDF5()</TT>.  The driver instance object is used
  with <TT>dbConnect</TT> (see page&nbsp;<A HREF="DBI.html#meth:dbConnect"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/share/latex2html/icons/crossref.png"></A>)
  for opening one or possibly more connections to one or more DBMS.

<P>
</DD>
<DT><STRONG><TT>dbListConnections(drv, ...)</TT>:</STRONG></DT>
<DD>list of current connections being handled by the <TT>drv</TT>
  driver.  May be <TT>NULL</TT> if there are no open connections.
  Drivers that do not support multiple connections may return the
  one open connection.

<P>
</DD>
<DT><STRONG><TT>dbGetInfo(dbObj, ...)</TT>:</STRONG></DT>
<DD>returns a list of name-value pairs of information about the
  driver.  

<P>
<I>Hint:</I> Useful entries could include 
  <DL>
<DT><STRONG><TT>name</TT>:</STRONG></DT>
<DD>the driver name (e.g., <TT>"RODBC"</TT>, <TT>"RPgSQL"</TT>); 
  
</DD>
<DT><STRONG><TT>driver.version</TT>:</STRONG></DT>
<DD>version of the driver;
  
</DD>
<DT><STRONG><TT>DBI.version</TT>:</STRONG></DT>
<DD>the version of the DBI that the driver 
   implements, e.g., <TT>"0.1-2"</TT>;
  
</DD>
<DT><STRONG><TT>client.version</TT>:</STRONG></DT>
<DD>of the client DBMS libraries (e.g., version
  of the <TT>libpq</TT> library in the case of <TT>RPgSQL</TT>);
  
</DD>
<DT><STRONG><TT>max.connections</TT>:</STRONG></DT>
<DD>maximum number of simultaneous 
  connections; 
  
</DD>
</DL>
  plus any other relevant information about the implementation, for instance, 
  how the driver handles upper/lower case in identifiers.

<P>
</DD>
<DT><STRONG><TT>dbUnloadDriver("driverName")</TT> (optional):</STRONG></DT>
<DD>frees all resources (local and remote) used by the driver.  
  Returns a logical to indicate if it succeeded or not.

<P>
</DD>
</DL>

<P>

<H2><A NAME="SECTION00043000000000000000"></A><A NAME="sec:DBIConnection"></A><BR>
Class <TT>DBIConnection</TT>
</H2>
This virtual class encapsulates the connection to a DBMS, and
it provides access to dynamic queries, result sets, DBMS session
management (transactions), etc.

<P>
<I>Note:</I> Individual drivers are free to implement single or
multiple simultaneous connections.

<P>
The methods defined by the <TT>DBIConnection</TT> class include:
<DL>
<DT><STRONG><TT>dbConnect(drv, ...)</TT>:</STRONG></DT>
<DD><A NAME="meth:dbConnect"></A>  creates and opens a connection to the database implemented by the
  driver <TT>drv</TT> (see Section&nbsp;<A HREF="DBI.html#sec:DBIDriver"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/share/latex2html/icons/crossref.png"></A>).  Each driver will
  define what other arguments are required, e.g., <TT>"dbname"</TT> or
  <TT>"dsn"</TT> for the database name, <TT>"user"</TT>, and <TT>"password"</TT>.
  It returns an object that extends <TT>DBIConnection</TT> in a
  driver-specific manner (e.g., the MySQL implementation could
  create an object of class <TT>MySQLConnection</TT> that extends 
  <TT>DBIConnection</TT>).

<P>
</DD>
<DT><STRONG><TT>dbDisconnect(conn, ...)</TT>:</STRONG></DT>
<DD>closes the connection, discards all pending work, and frees
  resources (e.g., memory, sockets).  Returns a logical indicating
  whether it succeeded or not.

<P>
</DD>
<DT><STRONG><TT>dbSendQuery(conn, statement, ...)</TT>:</STRONG></DT>
<DD>submits one statement to the DBMS.  It returns a <TT>DBIResult</TT>
  object. This object is needed for fetching data in case
  the statement generates output (see <TT>fetch</TT> on
  page&nbsp;<A HREF="DBI.html#meth:fetch"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/share/latex2html/icons/crossref.png"></A>), and it may be used for querying the
  state of the operation; see <TT>dbGetInfo</TT> and other 
  meta-data methods on page&nbsp;<A HREF="DBI.html#meth:res-others"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/share/latex2html/icons/crossref.png"></A>.

<P>
</DD>
<DT><STRONG><TT>dbGetQuery(conn, statement, ...)</TT>:</STRONG></DT>
<DD>submit, execute, and extract output in one operation.
  The resulting object may be a <TT>data.frame</TT> if
  the <TT>statement</TT> generates output.  Otherwise the
  return value  should be a logical indicating whether
  the query succeeded or not.

<P>
</DD>
<DT><STRONG><TT>dbGetException(conn, ...)</TT>:</STRONG></DT>
<DD>returns a list with elements <TT>errNum</TT> and <TT>errMsg</TT>
  with the status of the last DBMS statement sent on a given
  connection (this information may also be provided by the
  <TT>dbGetInfo()</TT> meta-data function on the <TT>conn</TT> object.

<P>
<I>Hint:</I> The ANSI SQL-92 defines both a status code and an
  status message that could be return as members of the list.

<P>
</DD>
<DT><STRONG><TT>dbGetInfo(dbObj, ...)</TT>:</STRONG></DT>
<DD>returns a list of name-value pairs describing the state of the
  connection;  it may return one or more meta-data, the actual driver
  method allows to specify individual pieces of meta-data (e.g., 
  maximum number of open results/cursors).

<P>
<I>Hint:</I> Useful entries could include 
  <DL>
<DT><STRONG><TT>dbname</TT>:</STRONG></DT>
<DD>the name of the database in use; 
  
</DD>
<DT><STRONG><TT>db.version</TT>:</STRONG></DT>
<DD>the DBMS server version (e.g., 
  "Oracle 8.1.7 on Solaris"; 
  
</DD>
<DT><STRONG><TT>host</TT>:</STRONG></DT>
<DD>host where the database server resides; 
  
</DD>
<DT><STRONG><TT>user</TT>:</STRONG></DT>
<DD>user name;
  
</DD>
<DT><STRONG><TT>password</TT>:</STRONG></DT>
<DD>password (is this safe?);
  
</DD>
</DL>
  plus any other arguments related to the connection (e.g., thread id,
  socket or TCP connection type).

<P>
</DD>
<DT><STRONG><TT>dbListResults(conn, ...)</TT>:</STRONG></DT>
<DD>list of <TT>DBIResult</TT> objects currently active on the connection
  <TT>conn</TT>.  May be <TT>NULL</TT> if no result set is active
  on <TT>conn</TT>.  Drivers that implement only one result set per
  connection could return that one object (no need to wrap it in
  a list).

<P>
</DD>
</DL>

<P>
<I>Note: The following are convenience methods that simplify
  the import/export of (mainly) data.frames.  The first five
  methods implement the core methods needed to <TT>attach()</TT>
  remote DBMS to the S search path. (For details, see
  [<A
 HREF="DBI.html#data-management:1991">2</A>,<A
 HREF="DBI.html#database-classes:1999">3</A>].)
</I>

<P>
<I>Hint:</I> For relational DBMS these methods may be easily implemented 
  using the core DBI methods <TT>dbConnect</TT>, <TT>dbSendQuery</TT>, 
  and <TT>fetch</TT>, due to SQL reflectance (i.e., one easily gets
  this meta-data by querying the appropriate tables on the RDBMS).

<P>
<DL>
<DT><STRONG><TT>dbListTables(conn, ...)</TT>:</STRONG></DT>
<DD>returns a character vector (possibly of zero-length) of object (table) 
  names available on the <TT>conn</TT> connection.

<P>
</DD>
<DT><STRONG><TT>dbReadTable(conn, name, ...)</TT>:</STRONG></DT>
<DD>imports the data stored remotely in the table <TT>name</TT>
  on connection <TT>conn</TT>. Use the field <TT>row.names</TT> 
  as the <TT>row.names</TT> attribute of the output data.frame.
  Returns a <TT>data.frame</TT>.

<P>
[Q: should we spell out how row.names should be created? E.g.,
  use a field (with unique values) as row.names?  Also, should
  <TT>dbReadTable</TT> reproduce a data.frame exported with
  <TT>dbWriteTable</TT>?]

<P>
</DD>
<DT><STRONG><TT>dbWriteTable(conn, name, value, ...)</TT>:</STRONG></DT>
<DD>write the object <TT>value</TT> (perhaps after coercing it to 
  data.frame) into the remote object <TT>name</TT> in connection
  <TT>conn</TT>.  Returns a logical indicating whether the operation
  succeeded or not.

<P>
</DD>
<DT><STRONG><TT>dbExistsTable(conn, name, ...)</TT>:</STRONG></DT>
<DD>does remote object <TT>name</TT> exist on <TT>conn</TT>?
  Returns a logical.

<P>
</DD>
<DT><STRONG><TT>dbRemoveTable(conn, name, ...)</TT>:</STRONG></DT>
<DD>removes remote object <TT>name</TT> on connection <TT>conn</TT>.
  Returns a logical indicating whether the operation succeeded or not.

<P>
</DD>
<DT><STRONG><TT>dbListFields(conn, name, ...)</TT>:</STRONG></DT>
<DD>returns a character vector
listing the field names of the remote table <TT>name</TT> on connection
<TT>conn</TT> (see <TT>dbColumnInfo()</TT> for extracting data type 
on a table).

<P>
</DD>
</DL>

<P>
<I>Note: The following methods deal with transactions and 
   stored procedures. All these functions are optional.
</I>
<DL>
<DT><STRONG><TT>dbCommit(conn, ...)</TT>(optional):</STRONG></DT>
<DD>commits pending transaction on the connection and returns 
  <TT>TRUE</TT> or <TT>FALSE</TT> depending on whether the operation
  succeeded or not.

<P>
</DD>
<DT><STRONG><TT>dbRollback(conn, ...)</TT>(optional):</STRONG></DT>
<DD>undoes current transaction on the connection and returns
  <TT>TRUE</TT> or <TT>FALSE</TT> depending on whether the operation
  succeeded or not.

<P>
</DD>
<DT><STRONG><TT>dbCallProc(conn, storedProc, ...)</TT>(optional):</STRONG></DT>
<DD>invokes a stored procedure in the DBMS and returns a <TT>DBIResult</TT> 
  object.

<P>
[Stored procedures are <I>not</I> part of the ANSI SQL-92 standard and
  vary substantially from one RDBMS to another.]

<P>
</DD>
</DL>

<P>

<H2><A NAME="SECTION00044000000000000000"></A><A NAME="sec:DBIResult"></A><BR>
Class <TT>DBIResult</TT>
</H2>

<P>
This virtual class describes the result and state of execution of
a DBMS statement (any statement, query or non-query).  The result set
<TT>res</TT> keeps track of whether the statement produces output
for R/S, how many rows were affected by the operation, how many
rows have been fetched (if statement is a query), whether there
are more rows to fetch, etc.  

<P>
<I>Note: Individual drivers are free to allow single or multiple
active results per connection.
</I>

<P>
[Q: Should we distinguish between results that return no data from those
that return data?]

<P>
The class <TT>DBIResult</TT> defines the following methods:
<DL>
<DT><STRONG><TT>fetch(res, n, ...)</TT>:</STRONG></DT>
<DD><A NAME="meth:fetch"></A>  fetches the next <TT>n</TT> elements (rows) from the result set
  <TT>res</TT> and return them as a data.frame.  A value of <TT>n=-1</TT>
  is interpreted as ``return all elements/rows''.

<P>
</DD>
<DT><STRONG><TT>dbClearResult(res, ...)</TT>:</STRONG></DT>
<DD>flushes any pending data and frees all resources (local and
  remote) used by the object <TT>res</TT> on both sides of the
  connection. Returns a logical indicating success or not.

<P>
</DD>
<DT><STRONG><TT>dbGetInfo(dbObj, ...)</TT>:</STRONG></DT>
<DD>returns a name-value list with the state of the result set.

<P>
<I>Hint:</I> Useful entries could include
   <DL>
<DT><STRONG><TT>statement</TT>:</STRONG></DT>
<DD>a character string representation of the
   statement being executed;
   
</DD>
<DT><STRONG><TT>rows.affected</TT>:</STRONG></DT>
<DD>number of affected records (changed, 
   deleted, inserted, or extracted);
   
</DD>
<DT><STRONG><TT>row.count</TT>:</STRONG></DT>
<DD>number of rows fetched so far;
   
</DD>
<DT><STRONG><TT>has.completed</TT>:</STRONG></DT>
<DD>has the statement (query) finished?
   
</DD>
<DT><STRONG><TT>is.select</TT>:</STRONG></DT>
<DD>a logical describing whether or not the
   statement generates output;
   
</DD>
</DL>
   plus any other relevant driver-specific meta-data.

<P>
</DD>
<DT><STRONG><TT>dbColumnInfo(res, ...)</TT>:</STRONG></DT>
<DD>produces a data.frame that describes the output of a query. 
   The data.frame should have as many rows as there are output
   fields in the result set, and each column in the data.frame
   should describe an aspect of the result set field (field name,
   type, etc.)

<P>
<I>Hint:</I> The data.frame columns could include 
   <DL>
<DT><STRONG><TT>field.name</TT>:</STRONG></DT>
<DD>DBMS field label;
   
</DD>
<DT><STRONG><TT>field.type</TT>:</STRONG></DT>
<DD>DBMS field type (implementation-specific);
   
</DD>
<DT><STRONG><TT>data.type</TT>:</STRONG></DT>
<DD>corresponding R/S data type, e.g., 
   <TT>"integer"</TT>;
   
</DD>
<DT><STRONG><TT>precision</TT>/<TT>scale</TT>:</STRONG></DT>
<DD>(as in ODBC terminology),  
   display width and number of decimal digits, respectively;
   
</DD>
<DT><STRONG><TT>nullable</TT>:</STRONG></DT>
<DD>whether the corresponding field may contain
   (DBMS) <TT>NULL</TT> values;
   
</DD>
</DL>
   plus other driver-specific information.

<P>
</DD>
<DT><STRONG><TT>dbSetDataMappings(flds, ...)</TT>(optional):</STRONG></DT>
<DD>defines a conversion between internal DBMS data types
  and R/S classes.  We expect the default mappings (see
  Section&nbsp;<A HREF="DBI.html#sec:data-mappings"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/share/latex2html/icons/crossref.png"></A>) to be by far the most
  common ones, but users that need more control may specify
  a class generator for individual fields in the result set.
  [This topic needs further discussion.]

<P>
</DD>
</DL>

<P>
<I>Note: The following are convenience methods that extract
information from the result object (they may be implemented
by invoking <TT>dbGetInfo()</TT> with appropriate arguments).  
</I>

<P>
<DL>
<DD><A NAME="meth:res-others"></A></DD>
<DT><STRONG><TT>dbGetStatement(res, ...)</TT>(optional):</STRONG></DT>
<DD>returns the DBMS statement (as a character string) associated
with the result <TT>res</TT>.

<P>
</DD>
<DT><STRONG><TT>dbGetRowsAffected(res, ...)</TT>(optional):</STRONG></DT>
<DD>returns the number of rows affected by the executed statement
  (number of records deleted, modified, extracted, etc.)

<P>
</DD>
<DT><STRONG><TT>dbHasCompleted(res, ...)</TT>(optional):</STRONG></DT>
<DD>returns a logical that indicates whether the operation has been
  completed (e.g., are there more records to be fetched?).

<P>
</DD>
<DT><STRONG><TT>dbGetRowCount(res, ...)</TT>(optional):</STRONG></DT>
<DD>returns the number of rows fetched so far.

<P>
</DD>
</DL>

<P>

<H1><A NAME="SECTION00050000000000000000"></A><A NAME="sec:data-mappings"></A><BR>
Data Type Mappings
</H1>
The data types supported by databases are different than the
data types in R and S, but the mapping between the ``primitive''
types is straightforward:  Any of the many fixed and varying
length character types are mapped to R/S <TT>"character"</TT>.
Fixed-precision (non-IEEE) numbers are mapped into either doubles
(<TT>"numeric"</TT>) or long (<TT>"integer"</TT>). Notice that many
DBMS do not follow the so-called IEEE arithmetic, so there are
potential problems with under/overflows and loss of precision, but
given the R/S primitive types we cannot do too much but identify
these situations and warn the application (how?).

<P>
By default dates and date-time objects are mapped to character
using the appropriate <TT>TO_CHAR</TT> function in the DBMS
(which should take care of any locale information).  Some RDBMS
support the type <TT>CURRENCY</TT> or <TT>MONEY</TT> which should be
mapped to <TT>"numeric"</TT> (again with potential round off errors).
Large objects (character, binary, file, etc.) also need to be mapped.
User-defined functions may be specified to do the actual conversion
(as has been done in other inter-systems packages <A NAME="tex2html3"
  HREF="#foot271"><SUP>2</SUP></A>).

<P>
Specifying user-defined conversion functions still needs to be 
defined.

<P>

<H1><A NAME="SECTION00060000000000000000"></A><A NAME="sec:utilities"></A><BR>
Utilities
</H1>
The core DBI implementation should make available to all
drivers some common basic utilities.  For instance:
<DL>
<DT><STRONG><TT>dbGetDBIVersion</TT>:</STRONG></DT>
<DD>returns the version of the currently attached DBI as a string.

<P>
</DD>
<DT><STRONG><TT>dbDataType(dbObj, obj, ...)</TT>:</STRONG></DT>
<DD>returns a string with the (approximately) appropriate data type for
  the R/S object <TT>obj</TT>.  The DBI can implement this following
  the ANSI-92 standard, but individual drivers may want/need to extend
  it to make use of DBMS-specific types.

<P>
</DD>
<DT><STRONG><TT>make.db.names(dbObj, snames, ...)</TT>:</STRONG></DT>
<DD>maps R/S names (identifiers) to SQL identifiers replacing 
  illegal characters (as <TT>"."</TT>) by the legal SQL <TT>"_"</TT>.

<P>
</DD>
<DT><STRONG><TT>SQLKeywords(dbObj, ...)</TT>:</STRONG></DT>
<DD>returns a character vector of SQL keywords (reserved words).  
  The default method returns the list of <TT>.SQL92Keywords</TT>,
  but drivers should update this vector with the DBMS-specific
  additional reserved words.

<P>
</DD>
<DT><STRONG><TT>isSQLKeyword(dbObj, name, ...)</TT>:</STRONG></DT>
<DD>for each element in the character vector <TT>name</TT> determine 
  whether or not it is an SQL keyword, as reported by the 
  generic function <TT>SQLKeywords</TT>.  Returns a logical vector
  parallel to the input object <TT>name</TT>.

<P>
</DD>
</DL>

<P>

<H1><A NAME="SECTION00070000000000000000"></A><A NAME="sec:open-issues"></A><BR>
Open Issues and Limitations
</H1>
There are a number of issues and limitations that the current
DBI conscientiously does not address on the interest of simplicity.
We do list here the most important ones.
<DL>
<DT><STRONG>Non-SQL:</STRONG></DT>
<DD>Is it realistic to attempt to encompass non-relational databases,
  like HDF5, Berkeley DB, etc.?

<P>
</DD>
<DT><STRONG>Security:</STRONG></DT>
<DD>allowing users to specify their passwords on R/S scripts may
  be unacceptable for some applications.  We need to consider
  alternatives where users could store authentication on files
  (perhaps similar to ODBC's <TT>odbc.ini</TT>) with more stringent 
  permissions.

<P>
</DD>
<DT><STRONG>Exceptions:</STRONG></DT>
<DD>the exception mechanism is a bit too simple, and it does not
  provide for information when problems stem from the DBMS
  interface itself.  For instance, under/overflow or loss of
  precision as we move numeric data from DBMS to the more limited
  primitives in R/S.

<P>
</DD>
<DT><STRONG>Asynchronous communication:</STRONG></DT>
<DD>most DBMS support both synchronous and asynchronous communications,
  allowing applications to submit a query and proceed while
  the database server process the query. The application is then
  notified (or it may need to poll the server) when the query has completed.
  For large computations, this could be very useful, but the DBI
  would need to specify how to interrupt the server (if necessary)
  plus other details.  Also, some DBMS require applications to use
  threads to implement asynchronous communication, something that
  neither R nor S-Plus currently addresses.

<P>
</DD>
<DT><STRONG>SQL scripts:</STRONG></DT>
<DD>the DBI only defines how to execute one SQL statement at a time, 
  forcing users to split SQL scripts into individual statements.
  We need a mechanism by which users can submit SQL scripts that
  could possibly generate multiple result sets;  in this case we 
  may need to introduce new methods to loop over multiple results
  (similar to Python's <TT>nextResultSet</TT>).

<P>
</DD>
<DT><STRONG>BLOBS/CLOBS:</STRONG></DT>
<DD>large objects (both character and binary) present some challenges both
  to R and S-Plus.  It is becoming more common to store images, sounds,
  and other data types as binary objects in DBMS, some of which can
  be in principle quite large. The SQL-92 ANSI standard allows up
  to 2 gigabytes for some of these objects.  We need to carefully
  plan how to deal with binary objects.

<P>
</DD>
<DT><STRONG>Transactions:</STRONG></DT>
<DD>transaction management is not fully described.

<P>
</DD>
<DT><STRONG>Additional methods:</STRONG></DT>
<DD>Do we need any additional methods? (e.g., <TT>dbListDatabases(conn)</TT>,
  <TT>dbListTableIndices(conn, name)</TT>, 
  how do we list all available drivers?)

<P>
</DD>
<DT><STRONG>Bind variables:</STRONG></DT>
<DD>the interface is heavily biased towards queries, as opposed to
  general purpose database development.  In particular we made
  no attempt to define ``bind variables''; this is a mechanism
  by which the contents of R/S objects are implicitly moved to
  the database during SQL execution.  For instance, the following
  embedded SQL statement

<P>
<PRE>
  /* SQL */
  SELECT * from emp_table where emp_id = :sampleEmployee
</PRE>
  would take the vector <TT>sampleEmployee</TT> and iterate over each
  of its elements to get the result.  Perhaps the DBI could at some
  point in the future implement this feature.

<P>
</DD>
</DL>

<P>

<H1><A NAME="SECTION00080000000000000000"></A><A NAME="sec:resources"></A><BR>
Resources
</H1>
The idea of a common interface to databases has been successfully
implemented in various environments, for instance:

<P>
Java's Database Connectivity (JDBC)
(http://www.javasoft.com/products/jdbc/index.htmlwww.javasoft.com).

<P>
In C through the Open Database Connectivity (ODBC)
(http://www.genix.net/unixODBCwww.genix.net/unixODBC).

<P>
Python's Database Application Programming Interface
(http://www.python.org/topics/databasewww.python.org).

<P>
Perl's Database Interface
(http://dbi.perl.orgdbi.perl.org).

<P>

<H2><A NAME="SECTION00090000000000000000">
Bibliography</A>
</H2><DL COMPACT><DD><P></P><DT><A NAME="mysql:2000">1</A>
<DD>
David Axmark, Michael Widenius, Jeremy Cole, and Paul DuBois.
<BR><EM>MySQL Reference Manual</EM>.
<BR><TT><A NAME="tex2html4"
  HREF="http://www.mysql.com/documentation/mysql">http://www.mysql.com/documentation/mysql</A></TT>, 2001.

<P></P><DT><A NAME="data-management:1991">2</A>
<DD>
John&nbsp;M. Chambers.
<BR>Data management in S.
<BR>Technical report, Bell Labs, Lucent Technologies,
  <TT><A NAME="tex2html5"
  HREF="http://stat.bell-labs.com/stat/doc">http://stat.bell-labs.com/stat/doc</A></TT>, 1991.

<P></P><DT><A NAME="database-classes:1999">3</A>
<DD>
John&nbsp;M. Chambers.
<BR>Database classes.
<BR>Technical report, Bell Labs, Lucent Technologies,
  <TT><A NAME="tex2html6"
  HREF="http://stat.bell-labs.com/stat/Sbook">http://stat.bell-labs.com/stat/Sbook</A></TT>, 1998.

<P></P><DT><A NAME="R-tcltk">4</A>
<DD>
Peter Dalgaard.
<BR>The R-Tcl/Tk interface.
<BR>In <EM>Proceedings of the Distributed Statistical Computing 2001
  Workshop</EM>, <TT><A NAME="tex2html7"
  HREF="http://www.ci.tuwien.ac.at/Conferences/DSC-2001">http://www.ci.tuwien.ac.at/Conferences/DSC-2001</A></TT>, 2001.
  Vienna University of Technology.

<P></P><DT><A NAME="PerlDBI:2000">5</A>
<DD>
Alligator Descartes and Tim Bunce.
<BR><EM>Programming the Perl DBI</EM>.
<BR>O'Reilly, 2000.

<P></P><DT><A NAME="mysql-dubois">6</A>
<DD>
Paul DuBois.
<BR><EM>MySQL</EM>.
<BR>New Riders, 2000.

<P></P><DT><A NAME="jdbc:2000">7</A>
<DD>
Jon Ellis, Linda Ho, and Maydene Fisher.
<BR><EM>JDBC 3.0 Specification</EM>.
<BR>Sun Microsystems, Inc, <TT><A NAME="tex2html8"
  HREF="http://java.sun.com/Download4">http://java.sun.com/Download4</A></TT>, 2000.

<P></P><DT><A NAME="rsdbi-dsc2001">8</A>
<DD>
Torsten Hothorn, David&nbsp;A. James, and Brian&nbsp;D. Ripley.
<BR>R/S interfaces to databases.
<BR>In <EM>Proceedings of the Distributed Statistical Computing 2001
  Workshop</EM>, <TT><A NAME="tex2html9"
  HREF="http://www.ci.tuwien.ac.at/Conferences/DSC-2001">http://www.ci.tuwien.ac.at/Conferences/DSC-2001</A></TT>, 2001.
  Vienna University of Technology.

<P></P><DT><A NAME="Xopen-sql">9</A>
<DD>
X/Open&nbsp;Company Ltd.
<BR><EM>X/Open SQL and RDA Specification</EM>.
<BR>X/Open Company Ltd., 1994.

<P></P><DT><A NAME="odbc:2001">10</A>
<DD>
Microsoft Inc, <TT><A NAME="tex2html10"
  HREF="http://www.microsoft.com/data/odbc/">http://www.microsoft.com/data/odbc/</A></TT>.
<BR><EM>Microsoft ODBC</EM>, 2001.

<P></P><DT><A NAME="R-dcom">11</A>
<DD>
Erich Neuwirth and Thomas Baier.
<BR>Embedding R in standard software, and the other way around.
<BR>In <EM>Proceedings of the Distributed Statistical Computing 2001
  Workshop</EM>, <TT><A NAME="tex2html11"
  HREF="http://www.ci.tuwien.ac.at/Conferences/DSC-2001">http://www.ci.tuwien.ac.at/Conferences/DSC-2001</A></TT>, 2001.
  Vienna University of Technology.

<P></P><DT><A NAME="Reese:2000">12</A>
<DD>
George Reese.
<BR><EM>Database Programming with JDBC and Java</EM>.
<BR>O'Reilly, second edition, 2000.

<P></P><DT><A NAME="BDR-RMR">13</A>
<DD>
B.&nbsp;D. Ripley and R.&nbsp;M. Ripley.
<BR>Applications of R clients and servers.
<BR>In <EM>Proceedings of the Distributed Statistical Computing 2001
  Workshop</EM>, <TT><A NAME="tex2html12"
  HREF="http://www.ci.tuwien.ac.at/Conferences/DSC-2001">http://www.ci.tuwien.ac.at/Conferences/DSC-2001</A></TT>, 2001.
  Vienna University of Technology.

<P></P><DT><A NAME="using-data:2001">14</A>
<DD>
Brian&nbsp;D. Ripley.
<BR>Using databases with R.
<BR><EM>R News</EM>, 1(1):18-20, January 2001.

<P></P><DT><A NAME="r-data-imp:2001">15</A>
<DD>
R&nbsp;Development&nbsp;Core Team.
<BR><EM>R Data Import/Export</EM>.
<BR><TT><A NAME="tex2html13"
  HREF="http://www.r-project.org">http://www.r-project.org</A></TT>, 2001.

<P></P><DT><A NAME="duncan-dsc2001">16</A>
<DD>
Duncan Temple&nbsp;Lang.
<BR>Embedding S in other languages and environments.
<BR>In <EM>Proceedings of the Distributed Statistical Computing 2001
  Workshop</EM>, <TT><A NAME="tex2html14"
  HREF="http://www.ci.tuwien.ac.at/Conferences/DSC-2001">http://www.ci.tuwien.ac.at/Conferences/DSC-2001</A></TT>, 2001.
  Vienna University of Technology.
</DL>

<H1><A NAME="SECTION000100000000000000000">
About this document ...</A>
</H1>
 <STRONG>A Common Database Interface (DBI)</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2002 (1.62)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-split 0 DBI.tex</TT>
<P>
The translation was initiated by David A. James on 2003-10-24<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot55">... class</A><A
 HREF="DBI.html#tex2html2"><SUP>1</SUP></A></DT>
<DD>A virtual class allows us to group
  classes that share some common characteristics, even if their
  implementations are radically different.

</DD>
<DT><A NAME="foot271">... packages</A><A
 HREF="DBI.html#tex2html3"><SUP>2</SUP></A></DT>
<DD>
  Duncan Temple Lang has volunteered to port the data conversion 
  code found in R-Jave, R-Perl, and R-Python packages to the DBI

</DD>
</DL><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="file:/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev_g.png">   
<BR>
<!--End of Navigation Panel-->
<ADDRESS>
David A. James
2003-10-24
</ADDRESS>
</BODY>
</HTML>
